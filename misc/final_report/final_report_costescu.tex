\documentclass[pageno]{jpaper}

\newcommand{\IWreport}{2014}

\usepackage{hyperref}
\usepackage[normalem]{ulem}
\usepackage{courier}
\usepackage{listings}
%\usepackage{amsmath}

\begin{document}
\lstset{language=Java,basicstyle=\ttfamily}

\title{
Settlers of Catan: Developing an Implementation of an Emerging Classic Board Game in Java}
\date{}

\topskip0pt
\author{Vladimir Costescu \\ Professor David P. Walker \\ Princeton University \\ August $29^{\text{th}}$, 2014}
\maketitle
\vspace*{\fill}
\begin{figure}
\centering
\includegraphics[width=150mm]{honor_code.png}
\end{figure}
\thispagestyle{empty} % don't display page number

\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\begin{abstract}
The goal of this project was to study the workings of the Settlers of Catan\textsuperscript{\textregistered} board game, seemingly simple but in reality quite complex, and faithfully implement a computer program in the Java\texttrademark programming language through which the game can be played. Furthermore, in the process of creating this implementation, I intended to learn the basics of producing a complex piece of software on my own and from scratch, with planning and design constituting major challenges in this endeavor. In this paper, I will discuss the background of the game and related work, the rules of the game, the steps and reasoning behind my implementation, the challenges I encountered in the course of development, and features of the game I would like to implement in the future.
\end{abstract}

\begin{doublespacing}
% begin content of the paper

\hypertarget{sec:motivation_and_goals_for_the_project}{}
\section{Motivation and Goals for the Project}

As with all human undertakings, large and time-consuming projects begin with an underlying motivation, a drive that propels those who engage in such endeavors to start a project and also to continue working on it, despite inevitable hardship during its course, until some goals are met and/or a calendar deadline comes to pass. This senior thesis project is no different. Two years ago, I was first exposed to Settlers of Catan, a three to four person board game, when a number of my fellow eating club members invited me to join them in playing a strange and complicated-looking board game. Having nothing better to do at the time, I accepted their offer and started learning how to play the game. Not surprisingly, it took me some time to begin to grasp the complex rules of the game, and I lost quite a few games, coming in dead last consecutively and consistently. I even became angry at my inability to win, and my friends, tauntingly, told me to "please continue to rage" as they laughed amongst themselves. With some practice, I was able to win sporadically, and I learned to not take the game so seriously and enjoy the social interactions facilitated by Settlers of Catan. 

Although those responsible for piquing interest in the game have since graduated, the knowledge that I gained during those spring days remained dormant in my mind for some time, until my memories of the game resurfaced this past fall and I decided to invest in a specimen of the game in order to play with my suitemates. During an ordinary gameplay session, an idea struck me: as a Computer Science major and Settlers of Catan aficionado, why not implement the game as a computer program for my senior thesis? I mulled over the idea briefly and decided that it would make for an interesting research opportunity, and thus I chose it as my topic of investigation for this paper. What follows is a report of the multifaceted learning experience in which I engaged in my study of Settlers of Catan, including the sum of small successes encountered throughout and also the many moments of frustration that inevitably crept up when things did not go according to plan.

\hypertarget{sec:background_and_related_work}{}
\section{Background and Related Work}

\hypertarget{sec:klaus_teuber_and_die_siedler_von_catan}{}
\subsection{Klaus Teuber and Die Siedler von Catan}

The story behind the genesis of the game is a curious and unexpected one, beginning with a frustrated dental technician who tinkered with board game ideas in his spare time in his basement workshop and culminating in a wildly successful commercial enterprise that has taken the world by storm and even prompted observers to posit that Settlers of Catan has the potential to displace the classic Parker Brothers game Monopoly in terms of household popularity \cite{raphel2014}. While such predictions have not come to pass, the profits generated by Catan and its numerous offshoots and adaptations have certainly enabled Klaus Teuber, the game's creator, to abandon his career as a dental technician and focus on board game development as a full-time job under the banner of his company, Catan GmbH.

Born in 1952 to a father specializing in the dental technician profession, Teuber studied chemistry as an undergratuate and then pursued the same career track as his father, becoming an apprentice in his father's dental lab in 1978 \cite{catanwebabout}. Just a few years later, in 1981, Teuber created his first game, a predecessor to Barbarossa, and embarked upon what would become a fruitful journey into the world of board games \cite{catanwebabout}. Throughout his dental career, Teuber continued experimenting with game design, fatefully releasing Die Siedler von Catan in Germany in 1995 and then the translated version, Settlers of Catan, in the United States in 1996 \cite{raphel2014}. Experiencing unexpected success with Catan, Teuber was able to afford quitting his job as dental lab managing director in 1999 and subsequently established his company, Catan GmbH, together with his son Guido in 2002 \cite{catanwebabout}.

\hypertarget{sec:impact_of_catan}{}
\subsection{Impact of Catan}

At the turn of the $21^{\text{st}}$ century, Catan was still a niche product despite enjoying solid success in its home country of Germany after Teuber won the 1995 Spiel des Jahres, but by 2011 it had sold over 18 million copies worldwide \cite{raphel2014,wingrove2011}. As Catan expanded beyond Germany, consumer demand grew so quickly that the resource needs for manufacturing the game exceeded available supply, and as a result Mayfair Games, Catan's publisher, had to reach out to American companies in order to acquire the necessary materials \cite{raphel2014}. Now available for purchase at major retailers such as Amazon.com, Barnes \& Noble, Target, and Walmart, Catan is considered mainstream enough to constitute serious competition for more entrenched titles such as Monopoly or Risk \cite{eskin2010,law2010,raphel2014,wingrove2011}. 

Not only does Catan compete with Monopoly for marketshare, it also competes for mindshare, offering an alternative to the strictly adversarial, capitalistic, and zero-sum world depicted in Monopoly \cite{eskin2010,wingrove2011}. In Monopoly, there is little opportunity for players to cooperate in order to improve each other's fortunes, nor is there any incentive to do so. Instead, the goal of Monopoly is to drive other players to financial ruin, and the game does not end until one player succeeds in driving the others into bankruptcy, an outcome that can take hours to achieve and likely induces boredom in the players who know that they will lose \cite{eskin2010}. Furthermore, although Monopoly's vicious and cutthroat nature unfortunately remains relevant today, more than 75 years after its creation, its teachings also serve to perpetuate the harmful behaviors that have led the world into catastrophic financial crisis, much in the same way as the solitary winner in the game leads all other participants to their economic downfall \cite{eskin2010}. In such a toxic climate, Catan attempts to change the status quo through its simple and innovative gameplay.

In contrast to Monopoly and Risk, Settlers of Catan encourages a cooperative rather than confrontational play style, and in fact it is quite difficult, if not impossible, to win the game without engaging with other players in trade for resources \cite{eskin2010,wingrove2011}. Due to the nature of the game, victory is seldom assured for any one player, and it is not uncommon for players in last place to make a miraculous comeback and win the game. This property of the game keeps players engaged and makes strategic planning more difficult, since each player's actions can provide a material advantage to another player and change the tide of the game \cite{eskin2010}. Furthermore, the interconnectedness of players' fortunes serves to discourage any excessively hostile actions by any one player, since the other players might then conspire to frustrate that player's progress in the game and even strip him or her of any chance of achieving victory. Finally, the conditions that align to create this deterrence mimic the real world quite well, making Catan a useful learning tool and a simplified model for how things actually work in practice, particularly in the domain of international relations \cite{eskin2010}. 

\hypertarget{sec:other_software_implementations_of_catan}{}
\subsection{Other Software Implementations of Catan}

Settlers of Catan has been implemented as a software program on a number of platforms, including PC / Mac, iPad / iPhone, Android, Xbox 360, and even Amazon Kindle \cite{catanwebgames}. In addition to these official versions, there also exist numerous open source incarnations of the game, including SolitaireSettlers, Pioneers, Settlers3d, JSettlers2, and HTML5Settlers \cite{clobusetal,detoni,fugate,maddock,monin}. Given the nature of the project at hand, I did not peruse the source code of any of these projects, since I did not want to taint my implementation with ideas taken from sources other than the Settlers of Catan physical board game that I purchased from Amazon.com and the rule booklet included within. It is worth noting that the Settlers of Catan legal team may have, at some point in the past, been involved in the removal of some non-official implementations of the game from the Web, meaning that the list of implementations provided here may not be complete \cite{masnick2011}.

\hypertarget{sec:catan_rules}{}
\section{Catan Rules \cite{catanwebrules}}

\hypertarget{sec:game_components}{}
\subsection{Game Components}

Before a description of the Settlers of Catan game rules can be attempted, it is necessary to first enumerate and explain the components of the game. The most basic element of the game is the board, which is composed of nineteen hexagonal tiles surrounded by six sea frame pieces. Eighteen of the tiles depict one of five attainable resources in the game, Wool, Grain, Lumber, Brick, and Ore, while the remaining tile depicts a resource-void desert. The sea frame pieces each have one or two sea ports, which are essential to maritime trade, an important game activity, adding up to a total of nine ports, four of which are of a generic type and the rest of which are of a particular resource type, granting a better trade ratio due to their specificity (note that the port locations are fixed but the port types can be shuffled using the extra port pieces included with the game). Augmenting the board at various stages in the game are roads, settlements, and cities, which can be placed by players during their turn. Enabling the placement of these game pieces are ninety-five resource cards, nineteen of each of the five types, which are collected by players during the normal course of gameplay. The acquisition of resource cards by players is controlled by eighteen dice roll chits, which are distributed across the eighteen resource tiles on the board, and by a pair of standard six-sided dice that are rolled during a normal turn of gameplay. Resource distribution can be curtailed by the placement of the robber piece, which initially starts out on the desert tile but can be moved when certain events occur during gameplay. In addition to being used to purchase roads, settlements, and cities, resource cards may also be used to purchase one of twenty-five development cards, which are shuffled in a deck and placed face down at the beginning of the game. Each development card is imbued with a special property that can affect the course of gameplay, and a small subset can even contribute to a player's victory. Finally, two special cards, Longest Road and Largest Army, can be granted to the player who meets certain special criteria, as alluded to by the titles of the cards.

\hypertarget{sec:game_setup}{}
\subsection{Game Setup}

The initial setup stage of the game proceeds according to a well-defined workflow. The first step is putting the board pieces together as described in significant detail in the game manual, whether following the prescribed static layout for beginners or using some degree of randomization. In the most randomized setup procedure that is mentioned in the rulebook, the hexagonal tiles, dice roll chits, and port types are shuffled before being used to construct the board. The hexagonal tiles are placed without further restriction after being shuffled, although in the physical version of the game players may opt to avoid excessive resource clustering. The dice roll chits are almost fully random, with the only stipulation being that the numbers six and eight may not be on adjacent hexes, due to their high chances of rolling (14\%) relative to the other possible numbers. Finally, the available port locations do not change in this setup, but the port types are distributed randomly across all the possible locations.

The next step is determining the order in which players will take their turns, and there are a few potential mechanisms for doing so. The simplest is for the oldest player to go first and then the remaining players to follow in descending order by age. Another option is for all players to roll the dice, where the player with the highest roll goes first and the remaining players follow in descending order by dice roll, and any dice roll ties are resolved by one or more rerolls. A third option is to alter either the age or dice roll mechanism such that the second, third, and potentially fourth players are ordered according to their seating location, either clockwise or counterclockwise. No matter which mechanism is chosen, the generated turn order remains the same throughout the game.

In the final step in the game setup process, each player is given the opportunity to place two settlements and two roads on the board. First, players take turns placing one settlement/road pair, such that settlements are placed on hex tile vertices, which are called "intersections", and roads are placed upon the edges connecting these vertices, with the stipulation that roads placed on the board must be connected to a settlement owned by the same player. Once each player has placed one settlement/road pair, the turn order reverses and the last player is the first to place the second pair, with the restrictions that the second settlement must not be an immediate neighbor of the first and that the second road must be attached to the second settlement. After each player has placed two settlements and roads, everyone collects one resource card of the same type as each hex tile adjacent to their second settlement. Finally, the turn order reverts to normal and the game proper can begin.

\hypertarget{sec:victory_conditions}{}
\subsection{Victory Conditions}

Victory in the three to four player version of Catan is achieved by the player who is the first to earn ten Victory Points, which are rewarded by the game when certain actions are completed. The simplest way to earn a Victory Point (VP) is to build a settlement, and as such all players start with two "free" points since each starting settlement counts for one point. Another way for players to gain VPs is to upgrade an existing settlement to a city, which grants an additional VP per city built. A third source of VPs is the development card deck, which primarily provides special gameplay advantages to players but also contains five cards that immediately grant one VP each to the player who acquires them. Respectively, these special cards are titled Chapel, Library, Market, Palace, and University. Finally, there exist two special cards that can be granted to players who satisfy their conditions. The first of these is Longest Road, which is valued at two VPs and is given to the player who has the longest connected road of length at least equal to five. Equivalent in VP value to Longest Road, the Largest Army card is given to the player who has played the largest number of Knight development cards, with a minimum of three played Knights necessary to acquire the card in the first place. Both of these cards can change ownership throughout the game, an event that happens whenever another player becomes the superlative road builder or army commander, respectively.

\hypertarget{sec:typical_turn_workflow}{}
\subsection{Typical Turn Workflow}

\hypertarget{sec:rolling_the_dice}{}
\subsubsection{Rolling the Dice}

The first step in any player's turn is to roll the two standard six-sided dice included with the game in order to determine resource production. For each hex tile whose dice roll chit displays the rolled number, all players who own a settlement or city at one of the tile's vertices receive one or two resources of the hex's type, respectively. If there are not enough resource cards to be distributed according to this rule, then no player receives any resources of the type or types lacking sufficient cards in the resource decks. A special rule, henceforth referred to as the robber's rule, applies to rolls where the dice total seven in any configuration. The robber's rule dictates that the player who rolled the dice must move the robber object from its current position to a different tile of that player's choosing. If the robber is moved to a tile where other players own settlements or cities, the current player chooses one of these players and "steals" one random resource card from that player's hand. For the duration of the robber's residence on the new tile, no resources are allocated for that tile when the dice are rolled. One other aspect of the robber's rule is that all players who possess more than seven resource cards must choose half of them to discard and return to the resource decks, where fractional numbers of cards are rounded down to the nearest integer. It is important to note that players cannot perform any other actions during their turn before rolling the dice, for example in an attempt to spend resource cards for fear of rolling a seven.

\hypertarget{sec:engaging_in_trade}{}
\subsubsection{Engaging in Trade}

After resources are allocated, a player may engage in either maritime trade or trade with other players, where "maritime trade" refers to the ability to swap multiple resource cards of the same type for one card of a different type without interacting with other players. The default maritime trade ratio is four to one, but this can be augmented by the ownership of settlements or cities on an intersection adjacent to a port along the edges of the Catan island. Specifically, generic ports grant a ratio of three to one for any kind of resource, while resource ports grant a two-to-one ratio only for a particular kind of resource, for example enabling a trade of two Lumber cards for any other resource card. For player-to-player resource trades, any combination of resource cards can be traded provided that both players agree to the trade, with the caveat that only the player whose turn it is may initiate player-to-player trades.

\hypertarget{sec:building_roads_settlements_cities_and_development_cards}{}
\subsubsection{Building Roads, Settlements, Cities, and Development Cards}

The primary activity undertaken during a player's turn is that of building objects, in accordance with the resource build costs printed on the four identical informational cards that are given to each player at the start of the game. Roads cost one Lumber card and one Brick card and may only be built adjacent to existing roads and/or existing settlements/cities owned by the same player. Furthermore, each hex tile edge permits the construction of only one road at a time, and roads may not be destroyed by any means during the course of the game. Finally, each player is allowed to build a maximum of fifteen roads, a restriction that grants paramount importance to careful road placement, particularly given the fact that roads cannot be reclaimed once placed. 

Settlements cost one of each distinct resource, with the exception of Ore, and may only be placed on hex tile vertices that do not already house a building of any type. Aside from the initial two settlements placed in the game setup stage, settlements must be built adjacent to an existing road owned by the same player. Furthermore, settlements must be separated by at least two hex tile edges, whether or not they are owned by the same player. Like roads, settlements cannot be destroyed, but players can replace their own settlements with cities provided that they have sufficient resources. Each player may build up to five settlements, but they can be reclaimed by city upgrades. Finally, players receive one Victory Point for the construction of each settlement, as described in the \hyperlink{sec:victory_conditions}{Victory Conditions} section above.

Cities cost two Wheat cards and three Ore cards and may only be placed on hex tile vertices with settlements owned by the same player. Like roads and settlements, cities cannot be destroyed by any means. Each player may build up to four cities on the board, and unlike settlements there is no way to reclaim cities once they are placed. Cities are considerably more valuable than settlements in terms of resource production capabilities, producing twice as many resources as settlements as described in the \hyperlink{sec:rolling_the_dice}{Rolling the Dice} section above. They are also the main vehicle for the pursuit of victory, granting two VPs each, and in fact it is virtually impossible to win the game without the strategic deployment of cities.

Development cards each cost one Wool, one Wheat, and one Ore, and they can be kept until their owner deems it appropriate to enter them into play. However, it is important to note that only one development card may be played during a player's turn, and furthermore a card cannot be played during the same turn in which it is acquired. The most common type of development card is the Knight, which constitutes a majority of fourteen out of twenty-five total development cards. When played, the Knight card allows a player to move the robber and steal a resource card from a player, as described above in the discussion of the robber's rule, but unlike the event where a seven is rolled, no players are required to discard half of their resource cards if they possess more than seven cards. Furthermore, Knights contribute to players' eligibility to receive the Largest Army card, with three Knight cards being the minimum necessary to acquire the card in the first place. It is important to reiterate that the Largest Army card only transfers ownership once another player's collection of played Knight cards exceeds the size of the next largest player-owned army.

The next most common development card type is that which immediately grants one Victory Point to the player who acquires it. There are five distinct cards in this category, as enumerated above in the \hyperlink{sec:game_components}{Game Components} section: Chapel, Library, Market, Palace, and University. Unlike other mechanisms for acquiring VPs, ownership of these cards is not made public to other players until their owner chooses to do so, which generally occurs when a player has enough VPs to win the game. Because of this property of VP cards, they are highly coveted and can be used strategically by clever players. In fact, the existence of VP cards is an important motivation for players to spend the resources necessary to acquire development cards, because they can be used to take other players by surprise and surge ahead to a leadership position.

The final category of development cards that can be built during a player's turn is that of progress cards. Conferring a specific gameplay advantage to the player who deploys them, there are two of each of three different types of progress cards available in the game. The Road Building card allows players to build two roads according to ordinary road-building procedures, at no additional cost beyond that which was required to acquire the card. This card cannot, however, grant players additional roads beyond the physical per-player limit of fifteen roads. The Monopoly card allows its owner to name one specific resource type and collect all cards of that type in the possession of all other players. Finally, the Year of Plenty card allows its owner to collect any two resource cards from the remaining pool of cards in the resource decks.

\hypertarget{sec:implementation_details}{}
\section{Implementation Details \cite{self2014}}

In the following sections, I will take the reader on a journey through the workflow of my Catan implementation, from the dynamic generation of the game board to the functioning of the game as it is played. The goal of the discussion is to show the reader how the program actually works rather than to dissect its components in a sterile clean-room. As such, the progression of the discussion will follow the rough outline of the program's operation, introducing concepts and data structures when the necessity arises and explaining important design decisions along the way. Despite this, many references to variables and methods in the code are made throughout the paper, so it is highly recommended for the reader to have a copy of the code close at hand. Additional discussion of design challenges will take place in the \hyperlink{sec:challenges_encountered}{Challenges Encountered} section of this paper.

\hypertarget{sec:insertion_point}{}
\subsection{Insertion Point}

As for all computer programs, execution begins with the \lstinline$main$ method, which in the case of the Catan implementation currently being discussed is in the \lstinline$Game$ class. The program is executed by typing \lstinline$java Game NUM_PLAYERS BOARD_RADIUS BOARD_DIMENSIONS$ at the command line, where \lstinline$NUM_PLAYERS$ is the number of players desired, \lstinline$BOARD_RADIUS$ indirectly describes the logical size of the board desired (note: a more detailed explanation of board radius can be found in the next section), and \lstinline$BOARD_DIMENSIONS$ lets the \lstinline$BoardDraw$ class know how large the rendered board should be in pixels (the graphical output is square, so only one parameter is needed). If no values are entered or the values entered cannot be parsed as integers, the program lets the user know that the default values (\lstinline$NUM_PLAYERS = 3$, \lstinline$BOARD_RADIUS = 3$, and \lstinline$BOARD_DIMENSIONS = 700$) will be used. Whether the user's input is taken into consideration or the default values are used, the program proceeds to create a new \lstinline$Game$ object, which sets into motion the constructor of that class. The constructor calls the \lstinline$startGame$ method, whose first line calls the \lstinline$init$ method of \lstinline$Rules$, the main subject of the next section.

\hypertarget{sec:the_rules_class}{}
\subsection{The \lstinline$Rules$ Class}

The purpose of the \lstinline$Rules$ class is to encapsulate as many of the rules of Settlers of Catan as possible. It contains a number of constants that describe immutable (but customizable) features of the game, such as the fixed set of 19 hex tiles that are used to create a board of standard size, the 18 dice roll chits that are to be placed on each tile except for the desert, and the cost of building roads, settlements, cities, and development cards. All of the remaining data structures in this class, including the logical structure of the game board, are generated dynamically from a single seed, the \lstinline$radius$ value entered by the user as described above. As its name suggests, this user-provided parameter measures the distance in hexes from the center of the board to the edge of the ocean surrounding it. A more useful definition of the radius, however, is the number of hex "rings" that make up the board. The center hex comprises the first ring, and the remaining rings grow outward in a concentric fashion. The default value for the radius is 3, as mentioned above, which produces an ordinary Catan game board. Since the radius can take values higher than 3, it is possible to play Catan with larger boards of arbitrary size. The manner in which the board is generated, a task split between the \lstinline$Rules$ and \lstinline$Board$ classes, is the subject of the next section.

\hypertarget{sec:dynamic_board_generation}{}
\subsection{Dynamic Board Generation}

\hypertarget{sec:numbering_conventions}{}
\subsubsection{Numbering Conventions}

When playing Settlers of Catan using a physical board, it is easy to refer to a desired hex or intersection simply by pointing to it with a finger. However, in order to interact with a computer-based representation of a Catan board, a unique identifier for each hex and intersection is required. The simplest and most obvious option is to use integer IDs for this task, but the immediate and inevitable issue that arises is the manner in which these IDs are assigned. It turns out that, for both hexes and intersections, the ring paradigm mentioned above makes it possible to perform this assignment in a logical and scalable way. For hexes, the numbering begins at 0, with the solitary hex in ring 0, and proceeds outward to the right and then in a counterclockwise direction. Thus, the hex immediately to the right of hex 0 is assigned ID 1, and then the hex up and to the left from hex 1 is assigned ID 2. The three rings of a standard board that result from this numbering scheme contain the following ID ranges, in ascending order: 0, 1-6, and 7-18. For intersections, a similar assignment mechanism can be followed, with each ring beginning at the bottommost intersection of the rightmost hex in the corresponding hex ring. The three rings that result contain the following ID ranges, in ascending order: 0-5, 6-23, and 24-53. This numbering paradigm lends itself to relatively straightforward implementation in code, as explained in the following section.

\hypertarget{sec:rings_of_catan}{}
\subsubsection{Rings of Catan}

The first step in the board generation process is the initialization of two data structures, \lstinline$hRings$ and \lstinline$iRings$, which store the IDs for hexes and intersections, respectively. Each is configured as a two-dimensional \lstinline$ArrayList$, where rows index the rings and columns index the items within each ring. For hexes, the size of each ring \lstinline$i$ (except for ring 0) is determined by \lstinline$i * HexShape.NUM_SIDES$, where \lstinline$HexShape.NUM_SIDES = 6$. For intersections, the size of each ring \lstinline$i$ is determined by \lstinline$((2 * i) + 1) * HexShape.NUM_SIDES$. Each entry in \lstinline$hRings$ and \lstinline$iRings$ stores the actual ID of a hex or intersection, so the net result of using these two-dimensional arrays is to allow IDs to be accessed using the row and column indices. This is immensely useful because, as the next two sections illustrate, there exist exploitable relationships between the column indices of adjacent rings.

\hypertarget{sec:hex_graph}{}
\subsubsection{Hex Graph}

The next step is to generate the hex graph, which is called \lstinline$hGraph$ and is stored as an adjacency list in a \lstinline$boolean$ two-dimensional array, where \lstinline$true$ indicates that two hexes (indexed by their integer IDs, as described above) are adjacent to each other. Having this data structure available and initialized is of crucial importance when attempting to randomize the dice roll chits, because the rules of Catan, enumerated in great detail above, stipulate that dice roll chits 6 and 8 cannot be adjacent to each other. In fact, in the absence of a data structure that stores information about which hexes are adjacent to each other, this rule cannot be enforced at all.

The generation of \lstinline$hGraph$ involves the use of \lstinline$hRings$ and two loops that iterate through the rows and columns of that data structure, such that all hexes are traversed in the same order in which their IDs were initially assigned, as described above. For each hex, the algorithm first looks at the next hex in the same ring, and then at the adjacent hexes in the next ring. Looking ahead within the same ring is a straightforward operation in that \lstinline$j$, the column index, is simply incremented by 1 at each step, with the caveat that modulus arithmetic must be used so that the last hex in a ring can "wrap around" to the first hex in that ring. However, determining which hexes in the next ring (if it exists, i.e. the current ring is not the last one) are to be examined and marked as adjacent to the current hex is a bit trickier and involves the introduction of a couple of simple concepts.

First, it is necessary to categorize hexes as either corners or not corners. A "corner" is defined in the following way: a hex is a corner if and only if its column index (its index inside the ring it is in) can be evenly divided by its row index (the index of the ring it is in). Visually speaking, the centers of all corner hexes lie on one of three axes that are perpendicular to the six sides of the center hex and pass through its center. Any hex that does not fit this criteria is not a corner. This distinction is important because corners are adjacent to three hexes in the next ring, while non-corners are only adjacent to two hexes in the next ring.

Second, the board needs to be divided into sextants, much in the same way as the two-dimensional Cartesian plane is divided into quadrants. As the name suggests, a "sextant" is one of six equal-sized slices into which a regular hexagonal Catan board (i.e. a board that has symmetry along the three corner axes) can be divided. Due to the nature of the ring indexing paradigm, it is easy to determine which sextant a given hex falls into simply by looking at its row and column indices, \lstinline$i$ and \lstinline$j$, respectively: \lstinline$sextant = j / i$. Note that, since \lstinline$i$ and \lstinline$j$ are both integers, integer division is performed and the remainder is ignored (although, as above, the existence of a remainder determines whether or not a hex is a corner). Also, observe that \lstinline$sextant$ can take values in the range 0-5.

Having introduced the corner and sextant concepts, it is now possible to explain the manner in which the hex graph algorithm determines, for a given hex, to which hexes in the next ring that hex is adjacent. A typical hex located at row index \lstinline$i$ and column index \lstinline$j$ in \lstinline$hRings$ is adjacent to the two hexes in the next ring (row index \lstinline$i + 1$) whose column indices are \lstinline$j + sextant$ and \lstinline$j + 1 + sextant$. The role of the \lstinline$sextant$ value here is to account for the fact that each ring contains 6 more hexes than the previous ring, distributed evenly across the 6 sextants. Thus, sextant 1 has to account for the extra hex contributed by sextant 0, sextant 2 has to account for the extra hexes contributed by sextants 0 and 1, and so on. If the current hex is not a corner, the story ends here. However, if it is a corner, then there is an extra hex in the next ring that must be considered, which is indexed by \lstinline$j - 1 + sextant$. An extra wrinkle is that it is necessary to account for wrap-around by using modulus arithmetic, since \lstinline$j - 1 + sextant$ can become negative if \lstinline$j$ and \lstinline$sextant$ are both 0.

\hypertarget{sec:intersection_graph}{}
\subsubsection{Intersection Graph}

Following the initialization of the hex graph, the next step is to generate the intersection graph, which is important because the edges between intersections constitute the only valid locations for the placement of roads during a game of Catan. Similar to the hex graph, the intersection graph is titled \lstinline$iGraph$ and is stored as an adjacency list in a \lstinline$boolean$ two-dimensional array, where \lstinline$true$ indicates that two intersections (indexed by their integer IDs, as described above) are adjacent to each other. Note that, although hexes and intersections are inextricably linked on a physical board by virtue of the board being flat, in the implementation presently being discussed hexes and intersections are logically separate entities (that said, the next section describes the initialization of the logical bridges between hexes and intersections).

The generation of \lstinline$iGraph$, like that of \lstinline$hGraph$, involves the use of two loops to traverse \lstinline$iRings$ in order of ascending intersection ID. However, a key difference is that the \lstinline$j$ index of the inner loop begins at 1 and ends at 0, using modulus arithmetic to wrap around to the beginning of the current ring when the end is reached. The reason for this will be explained in more detail shortly, but the basic point is that starting at 1 rather than 0 eliminates the need to have a special case for the first ring. For each intersection traversed, the algorithm first looks at the next intersection in the same ring, and then at the solitary adjacent intersection in the next ring, if one exists. Looking ahead within the same ring is a straightforward operation in that \lstinline$j$ is simply incremented by 1 at each step, but it takes a bit more work to determine when a link to the next ring needs to be created.

A basic observation is that every intersection in a ring contains 3 links to other intersections, 2 of which are in the same ring (pointing forward and backward) and one of which points to either the previous ring or the next ring. Since the algorithm only moves forward, it is only necessary to consider one of the links within the same ring, as described above. However, the third link alternates between pointing forward and backward, a fact that requires the use of a \lstinline$boolean$ called \lstinline$hasNextLink$, which flips back and forth between \lstinline$true$ and \lstinline$false$. The other challenge posed by the third link is determining the column index of the intersection in the next ring. Since the algorithm starts at \lstinline$j = 1$, the very first intersection examined for any ring always has a link to the next ring, specifically to column index 0. Thus, \lstinline$hasNextLink$ is initialized to \lstinline$true$ and \lstinline$ringIndexDiff$ to -1. Recall from the \hyperlink{sec:rings_of_catan}{Rings of Catan} section above that each ring has 12 more intersections than the previous ring, a difference which can be distributed across the 6 corners of each ring such that each corner contributes 2 extra intersections. This can be verified by visually comparing corner and non-corner hexes: for a corner hex, 2 of its 6 vertices are in one intersection ring and the remaining 4 in the other, whereas for a non-corner hex the split is 3 and 3. Now consider the fact that for each hex, corner or non-corner, 2 of the 6 sides connect two intersection rings. Since the algorithm only moves forward in a ring, only one of these sides is relevant, so hexes can be counted by the number of intersections in one ring that connect to the next ring. For any given hex ring \lstinline$i$, the number of non-corner hexes in a sextant is equal to \lstinline$i - 1$. Because extra intersections appear only at corner hexes, \lstinline$ringIndexDiff$ only gets incremented by 2 at a corner hex after one of the 2 corner hex intersections in the first ring is traversed. Thus, a counter variable \lstinline$waitTillNextInc$ can be set to \lstinline$i$, since the corner hex gets counted in addition to the non-corner hexes. For each sextant, this variable is initialized and then decremented at every other intersection, since as established above only every other intersection has a link to the next ring. Using \lstinline$hasNextLink$, \lstinline$ringIndexDiff$, \lstinline$waitTillNextInc$, and the logic described above, it is thus possible to determine when a link to the next ring needs to be created and also to compute the value of the column index of the intersection in the next ring to be linked to, the value of which is simply \lstinline$j + ringIndexDiff$.

Having explained how the algorithm functions, it is now possible to return to the minor detail of beginning the algorithm at column index 1 instead of 0 and explain this design choice more fully. The reason for this design decision is that the link between column indices 0 and 15 of rings 0 and 1, respectively, would be difficult to capture without resorting to the use of special cases, either having a special case for the entire first ring or just for that troublesome link. By starting at column index 1, it is possible to initialize \lstinline$ringIndexDiff = -1$ as above and allow the algorithm to increment this variable until it reaches 15 once column index 0 in ring 0 is finally traversed.

\hypertarget{sec:hex_to_intersection_mappings}{}
\subsubsection{Hex to Intersection Mappings}

As mentioned above, hexes and intersections are logically separate entities in the Catan implementation presently being discussed, but it is now necessary to create logical bridges between them, referred to henceforth as "mappings". These mappings occur in two directions: from hexes to intersections and from intersections to hexes, titled \lstinline$hIMapping$ and \lstinline$iHMapping$, respectively. Both of these data structures are two-dimensional \lstinline$ArrayList$s of integers, storing only intersection or hex IDs. \lstinline$hIMapping$ is set up such that the row indices refer to hex IDs and the columns store the 6 intersection IDs associated with each hex (the ordering and indices of the columns is irrelevant). \lstinline$iHMapping$ is set up in a similar manner, such that the row indices refer to intersection IDs and the columns store the 3 hex IDs associated with each intersection (again, the ordering and indices of the columns is irrelevant). \lstinline$hIMapping$ is needed for the scenario where the robber is moved to a new hex and the game has to know which players are eligible to have a resource card stolen by the player who moved the robber, by proxy of the player-owned settlements or cities that border that hex. \lstinline$iHMapping$ is needed to initialize the \lstinline$Intersection$ data structure (discussed in more detail later), so that when the time comes for players to collect resources after the dice are rolled, each \lstinline$Intersection$ owned by a player can know which hexes it borders and thus whether its player owner should be given one or more resource cards, depending on whether a settlement or city was built there.

The algorithm used to initialize these two mappings is reasonably straightforward, but there are several moving parts that require some explanation. Two loops are used to iterate through \lstinline$hRings$, such that \lstinline$j$ indexes the current hex ID in \lstinline$hRings$, as in the \hyperlink{sec:hex_graph}{Hex Graph} section above. However, for each hex, intersections are also iterated in parallel, and in fact the row index \lstinline$i$ serves the dual function of indexing rings for both \lstinline$hRings$ and \lstinline$iRings$, since the number of rings for each is equal to \lstinline$radius$. For each hex traversed, both the current intersection ring (at index \lstinline$i$ in \lstinline$iRings$) and the previous ring (at index \lstinline$i - 1$) are visited, with \lstinline$curIIndex$ and \lstinline$prevIIndex$ being used to keep track of intersection column indices for the current and previous rings, respectively. The concept of corner hexes is again used here to determine what the split of each hex's intersections is with regard to the current and previous intersection rings. Recall from the previous section that the split for corner hexes is 4 and 2 for the current and previous intersection rings and 3 and 3 for non-corner hexes. This information is used, for each hex, to traverse the intersections in the current intersection row, add an appropriate entry to each mapping (an intersection entry for \lstinline$hIMapping$ and a hex entry for \lstinline$iHMapping$), and then do the same for the previous intersection row. Once all hexes are traversed, the algorithm finishes and both mappings are fully initialized.

\hypertarget{sec:resources}{}
\subsubsection{Resources}

The official Catan rules specify exactly how many resource tiles of each type (Wool, Grain, Lumber, Brick, Ore, and also Desert) are to be represented when putting together the game board, and for the physical game these are fixed by the printed hex tiles provided in the box. However, since the implementation presently being discussed allows for the use of board sizes larger than that produced using the standard radius parameter of 3, it is necessary to implement a method that decides how many additional tiles of each type are to be added to the board once the fixed 19 are exhausted. Because this decision has to be made outside of the official rules, which do not provide any information about tile type distribution beyond the 19 given tiles, I used my discretion to choose a scalable and fair method for generating additional tiles. 

Before the simple decision algorithm is explained, however, a brief discussion of the basic \lstinline$Resource$ data type is required. The \lstinline$Resource$ class is essentially a wrapper for integer constants used to denote each different resource type, from \lstinline$DESERT = -1$ to \lstinline$ORE = 4$. The ordering of these integer values reflects the relative worth of each resource type, with \lstinline$DESERT$ being the least valuable since no resource cards of that type can be collected (and even if such cards existed, the standard build costs would still not include Desert). Other elements of \lstinline$Resource$ that are worth noting are the \lstinline$Color$ and \lstinline$String$ constants, for use by \lstinline$BoardDraw$ and for naming the resources, respectively. There also exists a \lstinline$static$ method called \lstinline$getResourceType$ (which overloads the \lstinline$getResourceType$ method that takes no arguments) for finding the integer value that corresponds to the given \lstinline$String$ parameter \lstinline$sResource$ containing the name of a resource. This method can be seen as the counterpart (in reverse) to the overridden \lstinline$toString$ method that gives the \lstinline$String$ name of a \lstinline$Resource$ instance. It is worth noting that \lstinline$Resource$ is used both for initializing the \lstinline$Hex$ data type (discussed in the \hyperlink{sec:hexes}{Hexes} section) and also as a resource card data type for initializing the resource deck. This dual use of \lstinline$Hex$ is the reason why \lstinline$DESERT$ is set to -1 rather than 0. Because the resource deck does not contain any Desert cards (as mentioned above) and is crucial to the functioning of the game (building anything costs resources), the latter use case is prioritized, so that \lstinline$NUM_TYPES$ can correspond to 1 greater than the last resource value (\lstinline$ORE$) in order to allow these integer constants to be appropriated as array indices for the \lstinline$ResourceBundle$ data type.

The hex tile generation algorithm begins by adding the standard 19 hex tiles, which are stored in \lstinline$DEFAULT_HEXES$ as an array of frequencies, to \lstinline$hexTiles$. A slight detail to take note of in the loop that implements this operation is that the indices in \lstinline$DEFAULT_HEXES$ are shifted by one, since \lstinline$DESERT = -1$ and thus cannot be used unmodified as an array index. If the user-provided radius parameter is equal to the default value of 3, then the story ends here. For larger boards, the algorithm continues by iterating through \lstinline$hRings$ and adding equal amounts, determined by \lstinline$curRingSize / Resource.NUM_TYPES$, of each non-Desert resource type to \lstinline$hexTiles$. If the current ring happens to be evenly divisible by 5 (the value of \lstinline$Resource.NUM_TYPES$), then the algorithm continues on to the next ring. Otherwise, a \lstinline$switch$ block decides what resource types to assign to the remaining hexes that are unaccounted for. I chose to implement this decision such that extra Desert tiles are added for all nonzero remainders except 3, in which case all non-Desert resources except Brick and Ore are added. The reasoning behind this is twofold: first, a huge Catan island would look odd with only one Desert tile on it, and second, the relative abundance of Wool, Grain, and Lumber on the standard Catan board is higher than that of Brick and Ore, so it makes sense to maintain this property for larger boards when possible.

\hypertarget{sec:dice_roll_chits}{}
\subsubsection{Dice Roll Chits}

Since every hex tile in Catan must have a dice roll chit associated with it (except for Desert tiles, but those can be dealt with by simply assigning them chits of value 7), it is necessary to generate a number of dice roll chits equal to the number of hex tiles in \lstinline$hRings$. For radius equal to 3, the default dice roll chit frequency distribution is used, which is stored in \lstinline$DEFAULT_DICE_ROLLS$. Because dice roll values are in the range 2-12 but the indices of \lstinline$DEFAULT_DICE_ROLLS$ are in the range 0-10, an offset of 2 must be used to transform loop indices \lstinline$i$ into actual rolls, as in the following code fragment: \lstinline$diceRolls.add(i + 2)$. 

For radius larger than 3, the default chits are added to \lstinline$diceRolls$ as in the standard case, but then an additional step of generating new chits for each hex ring is performed. It is essential to ensure that the chits generated here match up with the hex tiles already initialized, such that the number of dice rolls equal to 7 is equal to the number of Desert tiles and the number of dice rolls not equal to 7 is equal to the number of non-Desert tiles. A helpful observation here is that the number of non-Desert resources (5) happens to divide the number of non-Desert dice roll chits (10) evenly, so the assignment task is reduced to matching up the cases for nonzero values of \lstinline$curRingSize % (DEFAULT_DICE_ROLLS.length - 1)$ in \lstinline$initDiceRolls$, the method presently being discussed, to the cases for nonzero values of \lstinline$curRingSize % Resource.NUM_TYPES$ in \lstinline$initHexTiles$ (an in-depth discussion of which can be found in the previous section).

While \lstinline$curRingSize % (DEFAULT_DICE_ROLLS.length - 1)$ (range 0-9) has twice as many cases as \lstinline$curRingSize % Resource.NUM_TYPES$ (range 0-4), in fact the odd cases (1, 3, 5, and 7) can be discarded since all hex rings except the first one (already dealt with in the default chit initialization step) contain an even number of hexes. The remaining cases match up in the following way: values less than 5 correspond identically (0 to 0, 2 to 2, and 4 to 4), and values greater than 5 correspond to the result of taking their modulo for 5 (6 to 1 and 8 to 3). Recall that, in \lstinline$initHexTiles$, all cases except case 3 add Desert tiles, which means that cases 2, 4, and 6 in \lstinline$initDiceRolls$ must add the appropriate number of chits equal to 7. Cases 2 and 4 are straightforward, adding 2 and 4 chits equal to 7, respectively, but case 6 is a bit trickier because 5 chits not equal to 7 must be added in addition to the one chit equal to 7. The 5 most common dice rolls are chosen, with ties being broken in favor of larger values (an arbitrary choice to satisfy an unavoidable decision). In a similar way, case 8 adds one of each dice roll, except for 2, 7, and 12.

\hypertarget{sec:ports}{}
\subsubsection{Ports}

The components of board generation discussed thus far have all been located in \lstinline$Rules$, since that class deals with as many unchanging rules for a given board radius as possible. The last board generation component that fits this criteria is the task of determining how many maritime ports are to be added and what their types should be. For a standard board of radius 3, these details are specified by the rules of Catan, but again it is necessary to attempt to extrapolate from the rules in a reasonable way so that larger boards can be generated appropriately. Before the algorithm that does this is discussed, however, the basic \lstinline$Port$ data type must first be briefly explained. 

There are three basic port types represented in \lstinline$Port$, which are stored as integer constants: \lstinline$INLAND$, \lstinline$GENERIC$, and \lstinline$SPECIFIC$. \lstinline$INLAND$ is not technically a maritime port type, but it is used as a dummy port for intersections that are not associated with a real maritime port, thereby enforcing the game rule which states that, no matter where settlements and cities are built, players are allowed to trade 4 resources of one type for another resource of a different type. \lstinline$GENERIC$, as its name suggests, corresponds to the generic port type discussed in the \hyperlink{sec:engaging_in_trade}{Engaging in Trade} section above, which enables players to use a 3:1 trade ratio for any resource type. \lstinline$SPECIFIC$ corresponds to the resource port type discussed in the same section, enabling players to use a 2:1 trade ratio when trading a specific resource type for any other type. 

The methods in \lstinline$Port$ implement some basic functionality for interacting with ports, including retrieval methods for the fields of the class and an overridden \lstinline$toString$ method. The most interesting method in the class is titled \lstinline$compareRatio$ and takes a (different) \lstinline$Port$ instance and a \lstinline$Resource$ instance as parameters. The task of \lstinline$compareRatio$ is to determine whether \lstinline$this$ or \lstinline$p$ (the other port) has a better (lower) trade ratio for the given resource parameter \lstinline$r$. When a port is of the \lstinline$SPECIFIC$ type but for the wrong resource (i.e. a resource type different from that of \lstinline$r$), it is treated as functionally equivalent to an \lstinline$INLAND$ port. The output of \lstinline$compareRatio$ is an integer that follows the conventions of the \lstinline$compare$ method required for classes that implement the Java \lstinline$Comparable$ interface, which is to say that the return value is negative if \lstinline$p$ has the better ratio, 0 if the ratios are equal, and positive if \lstinline$this$ has the better ratio.

Now that the \lstinline$Port$ data type has been introduced, the discussion of the algorithm for generating the proper number of ports of each type can begin. The first step is to determine how many total maritime ports are needed for a given board radius, such that not too few and not too many ports are distributed around the edge of the island of Catan. Recall from the \hyperlink{sec:game_components}{Game Components} section above that a standard Catan board has 9 ports, 4 of which are generic and 5 of which are specific. A constant \lstinline$PORT_RATIO = 0.6$ attempts to extrapolate this rule to larger board sizes while still satisfying the initial rule constraint. Consider how the constant's value of 0.6 applies to a standard board: 60 percent of the 30 intersections in the last ring in \lstinline$iRings$ should be adjacent to a maritime port, a calculation that gives the result of 18, twice the standard number of ports specified in the official game rules. Since each maritime port in Catan is attached to two intersections, it is clear that the ratio of 0.6 satisfies the rules of Catan. For larger boards, multiplying by the port ratio can produce a result that is odd, which is undesirable but easily fixed by subtracting any remainder given by \lstinline$numPortsI % 2$, where \lstinline$numPortsI$ is the number of intersections that need to be attached to a maritime port.

In order to follow the standard split of generic and specific ports as closely as possible, the algorithm tries to assign the \lstinline$SPECIFIC$ type to about half of the needed ports and the \lstinline$GENERIC$ type to the ports that remain. However, in order to maintain fairness and balance, the number of specific ports needs to be divisible by the number of resource types (5) so that no resource is given preference over the others in terms of trading advantage. To achieve this, it is necessary to first compute \lstinline$(numPortsL / 2) % Resource.NUM_TYPES$ and subtract the result from \lstinline$Resource.NUM_TYPES$, where \lstinline$numPortsL$ is the number of logical ports (equal to one half of \lstinline$numPortsI$). The purpose of this calculation is to determine how many ports need to be added to the computed \lstinline$numPortsL / 2$ value so that the number of logical ports is divisible by 5. Once \lstinline$numSpecificL$ and \lstinline$numGenericL$ are computed, all that remains is to initialize the appropriate number of specific and generic ports using loops.

\hypertarget{sec:the_board_data_type}{}
\subsubsection{The \lstinline$Board$ Data Type}

The remaining steps in the dynamic board generation process involve some degree of randomness to ensure that every new game of Catan is different and exciting, and as such these steps cannot be implemented in the \lstinline$Rules$ class. The \lstinline$Board$ class exists for the purpose of picking up where \lstinline$Rules$ leaves off, taking advantage of the retrieval methods that provide access to the \lstinline$static$ fields of \lstinline$Rules$. It stores the remaining information about the game board, including the data structures containing the game hexes, intersections, and roads. The manner in which these data structures are initialized is the subject of the next few sections.

\hypertarget{sec:hexes}{}
\subsubsection{Hexes}

The game's hex tiles are stored in the \lstinline$hexes$ field (in \lstinline$Board$), which is an array of type \lstinline$Hex$, a data type acting as a wrapper for important information about hexes. \lstinline$Hex$ contains only 4 fields (and includes retrieval methods for accessing them): \lstinline$id$, \lstinline$resource$, \lstinline$diceRoll$, and \lstinline$hasRobber$, where \lstinline$id$ is the unique integer hex ID (discussed in the \hyperlink{sec:numbering_conventions}{Numbering Conventions} section) and the remaining 3 are self-explanatory. \lstinline$Hex$ also includes methods for updating \lstinline$hasRobber$, which are intuitively titled \lstinline$placeRobber$ and \lstinline$removeRobber$. Finally, it implements an overridden \lstinline$toString$ method, which is not currently called in the course of a game but was useful for debugging purposes.

The initialization of \lstinline$hexes$ begins with the retrieval of the hex tiles generated by the \lstinline$Rules$ class, which are then copied into a new \lstinline$ArrayList$ (in order to avoid modification of the \lstinline$hexTiles$ field in \lstinline$Rules$) titled \lstinline$shuffledLand$ and randomly reordered with \lstinline$Collections.shuffle$, a standard Java method. This array is then searched for Desert tiles, and the indices of these tiles are added to \lstinline$desertIndices$. The search is done with the help of \lstinline$ArrayList$'s built-in methods, specifically \lstinline$indexOf$, \lstinline$lastIndexOf$, and \lstinline$subList$, and also a temporary data structure titled \lstinline$partialLand$. The algorithm for searching works by finding the last index where a \lstinline$DESERT$ value occurs, storing the index in \lstinline$desertIndices$, and then taking a sub-array (starting from 0) which excludes that index and searching that sub-array (stored in \lstinline$partialLand$). The process continues until all desert indices have been saved (i.e. until \lstinline$indexOf$ returns -1). This step of finding desert indices is necessary because, as will be seen shortly, the desert indices must be known so that the dice roll values equal to 7 can be placed properly. 

The next step is to generate the shuffled dice rolls, a task performed by the \lstinline$getDiceRolls$ method, which takes \lstinline$desertIndices$ as an argument. Since the dice rolls have already been initialized, as discussed in the \hyperlink{sec:dice_roll_chits}{Dice Roll Chits} section above, all that needs to be done here is to shuffle them. However, there are a couple of issues: for the standard board size, the Catan rules stipulate that 6s and 8s cannot be adjacent to each other, and in general the indices of the dice rolls equal to 7 have to match up with the indices of the desert tiles. The resolution of the latter issue is delegated to the \lstinline$randomizeDiceRolls$ method, a helper to \lstinline$getDiceRolls$, which uses \lstinline$Collections.shuffle$ to randomly (and non-destructively) reorder the dice roll array acquired from \lstinline$Rules.getDiceRolls$, removes the dice rolls equal to 7, and then re-adds the 7s at the indices specified by \lstinline$desertIndices$. 

The former issue is dealt with in \lstinline$getDiceRolls$, which verifies whether or not the shuffled dice rolls returned by \lstinline$randomizeDiceRolls$ respect the Catan rules. The test is performed using the hex graph array retrieved with \lstinline$Rules.getHGraph$, where all possible adjacencies are checked to make sure 6s and 8s are not next to each other. The outer loop continues to re-generate the shuffled dice roll array with each iteration until there is no conflict, at which point \lstinline$getDiceRolls$ is finished and returns the shuffled dice roll array. Once the shuffled hex tiles and shuffled dice rolls have been generated, the final step is to iterate through each hex (the total number of hexes is retrieved using \lstinline$Rules.getNumHexes$) and initialize a new \lstinline$Hex$ data structure with the proper ID, \lstinline$Resource$, and dice roll. Finally, the robber is placed at a random desert index using \lstinline$Math.random$ and the \lstinline$placeRobber$ method of the \lstinline$Hex$ instance located at that index.

\hypertarget{sec:intersections}{}
\subsubsection{Intersections}

Following the initialization of \lstinline$hexes$, the next step in the board generation process is to initialize \lstinline$intersections$, an array of type \lstinline$Intersection$. As with the \lstinline$Hex$ type above, \lstinline$Intersection$ is used to wrap around some basic pieces of information about each intersection and expose some methods for manipulating intersections. There are 5 fields in this data type: \lstinline$id$, \lstinline$player$, \lstinline$building$, \lstinline$port$, and \lstinline$hexes$, where \lstinline$id$ is the integer ID assigned as explained in the \hyperlink{sec:numbering_conventions}{Numbering Conventions} section above, \lstinline$player$ is a reference to the \lstinline$Player$ instance that "owns" the intersection (the \lstinline$Player$ type is discussed in more detail later), \lstinline$building$ is a reference to the \lstinline$Building$ that resides at the intersection, \lstinline$port$ is a reference to the \lstinline$Port$ adjacent to the intersection (either a true maritime port or a dummy port), and \lstinline$hexes$ contains a list of \lstinline$Hex$es that border the intersection. 

Aside from the standard field retrieval methods, \lstinline$Intersection$ contains an overridden \lstinline$toString$ method (used for debugging purposes) and some convenience methods for manipulating the underlying \lstinline$Building$ type, which are used by the \lstinline$Player$ class when building settlements and cities. The \lstinline$Building$ type wraps around the integer building types \lstinline$OPEN$ (i.e. nothing built), \lstinline$SETTLEMENT$, and \lstinline$CITY$, implements a simple \lstinline$toString$ method, and provides two methods, titled \lstinline$canUpgrade$ and \lstinline$upgrade$, for manipulating the building (i.e. building a settlement or city by incrementing \lstinline$buildingType$). The convenience methods that \lstinline$Intersection$ exposes for the purpose of manipulating its \lstinline$building$ field are \lstinline$canBuild$, \lstinline$canBuildSettlement$, \lstinline$canBuildCity$, and \lstinline$upgrade$, all of which depend on \lstinline$Building$'s \lstinline$canUpgrade$ and \lstinline$upgrade$ methods to actually update the building. Note that \lstinline$Building$ and \lstinline$Intersection$ do not enforce the rules concerning building limits and costs, a task that is performed higher up in the class hierarchy (discussed in a later section).

Having explored the \lstinline$Intersection$ and \lstinline$Building$ data types, the discussion now turns to the initialization of \lstinline$intersections$. An important prerequisite for this initialization is the randomization of maritime port locations using the ports that have already been generated in the \lstinline$Rules$ class (see the \hyperlink{sec:ports}{Ports} section above for more details), a task performed by the \lstinline$randomizePorts$ helper method. This method begins by retrieving the list of ports using \lstinline$Rules.getPorts$, randomly shuffling this list, and reinitializing some temporary variables for the sake of code readability (since it would be overkill to create retrieval methods for these in \lstinline$Rules$). Then, a single dummy \lstinline$Port$ instance of type \lstinline$INLAND$ is created (titled \lstinline$inland$) and \lstinline$numIntersections - numI$ references to this instance are added to \lstinline$portsI$ (the list of port references for all intersections) so that all intersections not in the last ring of \lstinline$iRings$ are accounted for (\lstinline$numI$ is simply the size of the last ring). The last intersection ring is where the actual maritime ports are located in a game of Catan, so this is the point at which things get more interesting.

Recall the small note in the \hyperlink{sec:game_components}{Game Components} section that, for the physical version of Catan, port locations around the edge of the island are fixed but the port types can be shuffled around. In the Catan implementation presently being discussed, however, both port types and port locations are randomized. Having already explained how the port types are chosen and randomized, the conversation now turns to how the ports are distributed around the island. The first consideration is minimum spacing: since the official Catan board refrains from placing ports immediately next to each other, it seems reasonable to do the same in the computer version of the game. Thus, the first "pass" through the ports adds a reference to the dummy \lstinline$inland$ port instance between every two port instances (since each logical port is attached to two intersections) that are added to \lstinline$portsI$, such that no sequences of 4 consecutive intersections with maritime port references exist along the last intersection ring. 

In order to (slightly) randomize the port locations, the algorithm then loops through \lstinline$portsI$ and, at each step, randomly decides whether or not to add a reference to \lstinline$inland$. This continues until the size of \lstinline$portsI$ becomes equivalent to the size of the last intersection ring, so multiple passes through \lstinline$portsI$ may occur. Since the size of \lstinline$portsI$ increases every time another reference to \lstinline$inland$ is added, it is necessary to keep track of its size separately, using \lstinline$portsISize$ and incrementing it appropriately. After \lstinline$portsI$ is fully initialized, the last step in the \lstinline$randomizePorts$ method is to initialize \lstinline$Board$'s \lstinline$portLocations$ field, which will be used by \lstinline$BoardDraw$ to render the ports in the correct locations on the board. This is done simply by iterating through \lstinline$portsI$ and adding the indices of all non-\lstinline$INLAND$ ports to \lstinline$portLocations$. Once the ports are returned by \lstinline$randomizePorts$, it is finally possible to loop through and initialize the intersections by iterating over index \lstinline$i$ from 0 to \lstinline$Rules.getNumIntersections$, where each intersection is created using \lstinline$i$ (the integer ID), the proper port, and an array containing the hexes bordering the intersection (retrieved using \lstinline$Rules.getIHMapping$).

\hypertarget{sec:roads}{}
\subsubsection{Roads}

In the Catan implementation presently being discussed, roads are stored in a two-dimensional adjacency list array titled \lstinline$roads$, similar to \lstinline$iGraph$ (discussed in the \hyperlink{sec:intersection_graph}{Intersection Graph} section above). However, instead of having \lstinline$true$ values denoting the adjacency of intersections and \lstinline$false$ denoting non-adjacency, \lstinline$roads$ has \lstinline$Road$ objects where roads can be built and \lstinline$null$ where they cannot. The \lstinline$Road$ data type is very simple, containing only a pair of intersection IDs (\lstinline$iOne$ and \lstinline$iTwo$) and a reference to a \lstinline$Player$ owner. However, it does contain a few useful methods to be used for interacting with roads: \lstinline$other$, \lstinline$common$, \lstinline$both$, \lstinline$isNeighbor$, \lstinline$canBuild$, and \lstinline$build$, where the first 4 deal with interacting with intersection IDs and the last 2 deal with the player owner of the road. \lstinline$other$ and \lstinline$common$ are closely related: the former takes an ID and returns the other ID (or \lstinline$Constants.INVALID$, which is equal to -10), while the latter takes a \lstinline$Road$ reference \lstinline$r$ and returns the ID that \lstinline$this$ and \lstinline$r$ have in common, if any (or \lstinline$Constants.INVALID$ if there is no shared intersection). \lstinline$isNeighbor$ builds on \lstinline$common$, returning \lstinline$true$ if there is a common intersection and \lstinline$false$ otherwise, and \lstinline$both$ simply returns both intersection IDs (it is worth noting that these are always sorted in ascending order due to how the \lstinline$Road$ constructor behaves). 

The remaining methods in \lstinline$Road$ (aside from \lstinline$getPlayer$, a retrieval method for the \lstinline$player$ field, and a debugging \lstinline$toString$ method) are used to assign an owner to the road, since \lstinline$Road$s are initialized with a \lstinline$null$ owner: \lstinline$canBuild$ verifies that the \lstinline$Road$ is unowned, and \lstinline$build$ changes the owner to the one provided as a parameter. Note that \lstinline$Road$ does not check whether players have enough resources to build roads, since this verification is performed higher up in the class hierarchy (discussed in a later section). Having discussed the \lstinline$Road$ data type, it is now possible to explain the initialization of \lstinline$Board$'s \lstinline$roads$ field, which is much easier than that of hexes and intersections (discussed in great detail above). Since \lstinline$roads$ is parallel to \lstinline$iGraph$, which has already been initialized in \lstinline$Rules$, all that needs to be done is to create a new \lstinline$Road$ instance with row index \lstinline$i$ and column index \lstinline$j$ wherever there exists a \lstinline$true$ value in \lstinline$iGraph$. Once the last \lstinline$Road$ is created, the game board is fully initialized and is ready to be rendered by \lstinline$BoardDraw$, the subject of the next section.

\hypertarget{sec:rendering_the_board_with_stddraw}{}
\subsection{Rendering the Board with \lstinline$StdDraw$ \cite{princetoncs}}

The \lstinline$BoardDraw$ class is responsible for graphically rendering the game board, using the \lstinline$StdDraw$ library (part of the Princeton IntroCS package of standard libraries) to create a new window with a blank canvas and then draw each board element at the proper coordinates. The minutiae of performing the actual drawing operations are dealt with by \lstinline$StdDraw$, so the main task of \lstinline$BoardDraw$ is to calculate the proper coordinates for the various Catan board elements and call the appropriate \lstinline$StdDraw$ methods. To initialize a \lstinline$BoardDraw$ object, all that is needed is a reference to a \lstinline$Board$ and, optionally, a \lstinline$dim$ parameter that determines the dimensions of the rendered window in pixels (the window is square, so only one value is necessary). If no dimension parameter is provided, the \lstinline$DEFAULT_DIM = 700$ value is used instead, which works well for a standard size board but is too small for larger boards. The \lstinline$dim$ field is used to dynamically compute the dimensions of the game elements to be drawn, such that the components of a rendered board of any size are approximately proportionate and visually pleasing. These computed values will be discussed in more detail in the relevant sections on drawing different board elements, but it is worth noting here that the values are all calculated in the \lstinline$initCoords$ and \lstinline$initCanvas$ methods, such that the \lstinline$BoardDraw$ instance is ready to draw the board using the \lstinline$draw$ method once the class constructor returns.

\hypertarget{sec:the_hexshape_data_type}{}
\subsubsection{The \lstinline$HexShape$ Data Type}

Central to \lstinline$BoardDraw$'s dimension and coordinate calculations is the \lstinline$HexShape$ data type, whose main task is to compute the $x$ and $y$ coordinates of the 6 vertices of a hex using the coordinates of the center point of the hex and the size of one of 3 possible dimensions of the hex. In order to explain the inner workings of \lstinline$HexShape$, it is first necessary to introduce some terms and concepts involved in the geometry of a regular hexagon (i.e. one with sides and angles of equal size). First and simplest is the rotation of a hex, which can either be \lstinline$FLAT$ or \lstinline$BALANCE$. The flat orientation is such that a hex has two of its sides positioned parallel to the $x$ axis. Conversely, the balanced orientation is such that a hex has two of its sides positioned parallel to the $y$ axis. The names of these orientations refer to how a hexagon would behave if placed on an infinite line in a two-dimensional world where gravity acts downward (i.e. in the negative $y$ direction): a \lstinline$FLAT$ hexagon would remain stationary, while a \lstinline$BALANCE$ hexagon would "roll" in the negative or positive $x$ direction unless perfectly balanced on its bottommost vertex.

The next detail to be considered is the geometry involved in describing a regular hexagon. The first and most obvious dimension is the length of a side, the \lstinline$HexShape$ field for which is aptly titled \lstinline$side$. Another hexagon dimension is defined by the perpendicular distance between two parallel sides, which is titled \lstinline$flatHeight$ for the \lstinline$FLAT$ orientation and \lstinline$balanceWidth$ for the \lstinline$BALANCE$ orientation. The third and final dimension is the distance between the farthest 2 vertices, which is titled \lstinline$flatWidth$ and \lstinline$balanceHeight$. These dimensions can also be defined in a different way. Consider an arbitrary vertex indexed by $v$, where any of its neighbors is $v + 1$, the next neighbor is $v + 2$, and so on. The distance between $v$ and $v + 1$ is \lstinline$side$, the distance between $v$ and $v + 2$ is \lstinline$flatHeight$, and, finally, the distance between $v$ and $v + 3$ is \lstinline$flatWidth$. 

In order to initialize a \lstinline$HexShape$ instance, 5 parameters are needed: \lstinline$xCenter$, \lstinline$yCenter$, \lstinline$rotation$, \lstinline$param$, and \lstinline$selector$, where \lstinline$xCenter$ and \lstinline$yCenter$ are the coordinates of the center of the hexagon, \lstinline$rotation$ describes the orientation, \lstinline$param$ is the value of one of the 3 dimensions defined above, and \lstinline$selector$ specifies which of the dimensions is provided by \lstinline$param$. Since only one of the 3 dimensions defined above is needed to compute the other two, \lstinline$param$ is the only argument that needs to be passed to one of the 5 \lstinline$given*$ methods (where \lstinline$*$ denotes any of the 5 names for the 3 dimensions), all of which use the geometric relationship among the dimensions: $side = x$, $flatHeight = \sqrt{3}x$, and $flatWidth = 2x$.

Once the 5 dimension aliases are calculated, the final step is to compute the coordinates of the 6 vertices, which is done in the \lstinline$computeCoords$ method. This method takes advantage of the fact that all 6 vertices are equidistant from the center of a regular hex, where the distance is equal to one half of a side. Thus, the 6 coordinate pairs are calculated once, and then \lstinline$rotation$ is used to determine which coordinate array corresponds to \lstinline$xCoords$ and which corresponds to \lstinline$yCoords$. The resulting order of coordinates is as follows: in the \lstinline$FLAT$ case, the vertex indices ascend clockwise from the vertex with the lowest $x$ coordinate, and in the \lstinline$BALANCE$ case, the indices ascend counterclockwise from the vertex with the lowest $y$ coordinate.

\hypertarget{sec:boarddraw_preliminaries}{}
\subsubsection{\lstinline$BoardDraw$ Preliminaries}

Having explored the important \lstinline$HexShape$ data type, the discussion can now turn to the \lstinline$BoardDraw$ class proper. When its constructor is called, \lstinline$BoardDraw$ first stores references to the relevant fields of the provided \lstinline$board$ parameter and also some \lstinline$static$ fields of \lstinline$Rules$, particularly \lstinline$hRings$ and \lstinline$iRings$. Then, it computes \lstinline$xCenter$ and \lstinline$yCenter$ (using \lstinline$dim$) and initializes a large flat \lstinline$HexShape$ to be used as the "ocean" in which the island of Catan will reside. Other important computed values include \lstinline$w$, \lstinline$h$, and \lstinline$s$, which are the \lstinline$balanceWidth$, \lstinline$balanceHeight$, and \lstinline$side$ dimensions of a typical hex. \lstinline$w$ is calculated so that the entire width of a Catan board can fit in the ocean hex and still have room for a one hex padding on each side, where the width of the board in hexes is \lstinline$(2 * radius) - 1$. \lstinline$h$ and \lstinline$s$ are calculated from \lstinline$w$ when a \lstinline$HexShape$ is created to represent the center hex (located at row and column indices 0 in \lstinline$hRings$). 

\hypertarget{sec:the_getnextx_and_getnexty_methods}{}
\subsubsection{The \lstinline$getNextX$ and \lstinline$getNextY$ Methods}

Somewhat surprisingly, two humble and simple methods underpin the coordinate calculation algorithms for hexes, intersections, and ports. As their names suggest, these methods compute the "next" coordinate pair given the "current" coordinate pair and the relevant \lstinline$HexShape$ dimensions, where "current" and "next" refer to indices in a loop (since these methods are meant to be loop helpers). The concrete meanings of "current" and "next" are context-specific, but the general idea is that there is a movement from one point to another in one of 6 possible cardinal directions. These directions are best understood as lines of "outward" motion that are perpendicular to the 6 sides of a reference \lstinline$BALANCE$ hex, where "outward" refers to increasing distance from the center of the hex. The cardinal directions represented are northwest, west, southwest, southeast, east, and northeast, which are stored as constants in \lstinline$HexShape$ and referred to by their abbreviations (\lstinline$NW$, \lstinline$W$, \lstinline$SW$, \lstinline$SE$, \lstinline$E$, and \lstinline$NE$). The numeric values of these constants were purposely chosen to facilitate the computation of hex coordinates (the subject of the next section), but they also turned out to be useful for the computation of intersection coordinates (together with the application of some cleverness).

\hypertarget{sec:hex_coordinates}{}
\subsubsection{Hex Coordinates}

Since the \lstinline$HexShape$ data type performs the actual hex coordinate calculation, all that \lstinline$BoardDraw$ needs to do in order to compute the hex coordinates is to find all the hex centers and then initialize an instance of \lstinline$HexShape$ for each hex. Using \lstinline$hRings$ (introduced in the \hyperlink{sec:rings_of_catan}{Rings of Catan} section), sextants (introduced in the \hyperlink{sec:hex_graph}{Hex Graph} section), and the \lstinline$getNextX$ and \lstinline$getNextY$ methods (introduced in the previous section), it is actually quite simple to find the hex center coordinates. The algorithm loops through each ring in \lstinline$hRings$ (except for the first one, which is just the solitary center hex and can be initialized separately), first calculating the coordinates of the hex at column index 0 (i.e. the initial \lstinline$curHex$), where \lstinline$hexYCenters[curHex]$ is always equal to \lstinline$yCenter$ and \lstinline$hexXCenters[curHex]$ is simply \lstinline$i$ hex widths to the right of \lstinline$xCenter$, expressed in code as \lstinline$xCenter + (i * w)$. The "magical" step in the algorithm occurs when transitioning from a given \lstinline$curHex$ to \lstinline$nextHex$: the \lstinline$getNextX$ and \lstinline$getNextY$ methods are called with parameters specifying the current coordinate, the appropriate combination of \lstinline$w$, \lstinline$h$, and \lstinline$s$, and the sextant (which is equal to \lstinline$j / i$). The crucial observation here is that the sextant number (in the range 0-5) neatly coincides with the \lstinline$HexShape$ cardinal directions described in the previous section, a correspondence purposely established by design.

\hypertarget{sec:intersection_coordinates}{}
\subsubsection{Intersection Coordinates}

The intersection coordinate calculation algorithm is somewhat more complicated than that for computing hex coordinates, but with some creative effort the same underlying mechanism of relying on the \lstinline$getNextX$ and \lstinline$getNextY$ methods can be applied. The clever insight here is that an intersection ring can be separated into two halves, one for intersections with odd column indices and one for even-indexed intersections, and these halves can be traversed simultaneously using two special indices, unimaginatively titled \lstinline$iOdd$ and \lstinline$iEven$. Recall from \hyperlink{sec:the_hexshape_data_type}{The \lstinline$HexShape$ Data Type} that the distance between a vertex and its second-degree neighbor is simply \lstinline$balanceWidth$, which is also the distance between any two hex centers. Not only are these distances the same, they are defined by the same 6 possible distance vectors (i.e. line segments of length \lstinline$balanceWidth$ oriented in the 6 \lstinline$HexShape$ cardinal directions). Thus, the same \lstinline$getNextX$ and \lstinline$getNextY$ methods that were used to compute the hex centers can be called upon without modification, so the only task left is to determine which cardinal directions to use and when.

The overall code in the \lstinline$initInterCords$ method utilizes a 3-loop structure, where the outer loop iterates over \lstinline$i$ in \lstinline$iRings$, the middle loop iterates over \lstinline$j$ for each \lstinline$HexShape$ cardinal direction, and the inner loops iterate over \lstinline$k$ for values \lstinline$oddInc$ and \lstinline$evenInc$. These values flip back and forth between \lstinline$i + 1$ and \lstinline$i$, which count the number of hops from second-degree neighbor intersection to second-degree neighbor in the same direction before the direction has to change to a different cardinal orientation, for odd and even intersections. In programmatic terms, the flip is accomplished by \lstinline$((*Inc - i + 1) % 2) + i$, where \lstinline$*Inc$ represents \lstinline$oddInc$ and \lstinline$evenInc$. This may look complicated, but all that is happening here is that \lstinline$i$ is subtracted out, odd and even get swapped by taking the modulo 2, and then \lstinline$i$ is added back. The \lstinline$j$ and \lstinline$k$ loops taken together create a situation where, for each cardinal direction (\lstinline$j$), \lstinline$k$ new intersections are traversed by following the current cardinal vector (of magnitude \lstinline$balanceWidth$). When these two loops finish, the result is that an entire intersection ring has been traversed, the size of which is equal to the sum of the sizes of the two halves indexed by \lstinline$iOdd$ and \lstinline$iEven$. The role of \lstinline$getNextX$ and \lstinline$getNextY$ in this algorithm is to calculate the next intersection coordinate for both the \lstinline$oddInc$ and \lstinline$evenInc$ \lstinline$k$ loops. Thus, the role of the \lstinline$i$, \lstinline$j$, and \lstinline$k$ loops is really just to iterate appropriately so that the \lstinline$getNextX$ and \lstinline$getNextY$ workhorse methods can perform their essential task of calculating intersection coordinates.

\hypertarget{sec:port_coordinates}{}
\subsubsection{Port Coordinates}

The last coordinates that need to be calculated before the board can be rendered are those of the maritime ports scattered around the edge of the island of Catan. The only prerequisite needed to begin this computation is the knowledge of the coordinates of the intersections that are attached to ports, and this information is acquired by accessing \lstinline$interXCoords$ and \lstinline$interYCoords$ using the intersection indices stored in \lstinline$portLocations$, which (as discussed in the \hyperlink{sec:intersections}{Intersections} section) is initialized by the \lstinline$randomizePorts$ method in the \lstinline$Board$ class and can be accessed using the \lstinline$getPortLocations$ retrieval method. The algorithm loops through \lstinline$portLocations$, incrementing \lstinline$i$ by 2 after each iteration because the number of actual ports is half that of intersections attached to ports. Since the coordinates of these intersections have already been computed in \lstinline$initInterCoords$, the only thing left to do is to travel an appropriate distance outward from the port intersections and record the resulting coordinates. 

The distance and direction to be traveled is chosen such that each port coordinate lies at precisely the location where a hex center would be found if the board had at least one more hex ring. It is easier to start at the port intersections rather than at the centers of the hexes in the last hex ring, so the distance is reduced by a factor of 2, since the port intersections are positioned exactly midway between the existing hex centers and the desired port centers. This means that, when calling the \lstinline$getNextX$ and \lstinline$getNextY$ methods, it is merely necessary to provide half of the \lstinline$w$, \lstinline$h$, and \lstinline$s$ fields in \lstinline$BoardDraw$, along with the appropriate \lstinline$HexShape$ cardinal direction and the coordinates of the closest point that is equidistant from the intersections in each pair. These directions are determined by calculating the difference between the $x$ and $y$ coordinates of each intersection pair adjacent to a port and checking which case the differences fall under (note that it is necessary to round the differences to ensure that the cases which check for zero differences are properly detected). These cases are chosen empirically with regard to the geometry of the game board, specifically the direction that the imaginary line perpendicular to the line segment connecting each intersection pair must follow in order to move away from the board. Finally, the coordinates computed by \lstinline$getNextX$ and \lstinline$getNextY$ are stored in \lstinline$portXCoords$ and \lstinline$portYCoords$ at index \lstinline$i / 2$, undoing the doubling of \lstinline$i$ caused by traversing \lstinline$portLocations$ by twos.

\hypertarget{sec:drawing_hexes}{}
\subsubsection{Drawing Hexes}

Now that the hex coordinates are known, it is time to actually draw the hexes using \lstinline$StdDraw$ method calls. The first step is to draw a filled hexagon of the appropriate color for each hex in \lstinline$hexes$, which is done by calling \lstinline$StdDraw.setPenColor$ to change the color and then \lstinline$filledPolygon$ to perform the drawing. The proper color for each \lstinline$Resource$ type was determined empirically by sampling from the hex tile graphics in the official game rules, with the resulting correspondences of \lstinline$0xFFFF99$ for \lstinline$DESERT$, \lstinline$0x00CC00$ for \lstinline$WOOL$, \lstinline$0xFFCC00$ for \lstinline$GRAIN$, \lstinline$0x006600$ for \lstinline$LUMBER$, \lstinline$0xCC6600$ for \lstinline$BRICK$, and \lstinline$0x666666$ for \lstinline$ORE$, where all colors are in the RGB (red-green-blue) colorspace. Since \lstinline$StdDraw$ does not support drawing a border of a different color on a drawn polygon, it is necessary to simulate borders on each hex by setting the pen color to \lstinline$StdDraw.BLACK$ (shorthand for Java's \lstinline$Color.BLACK$) and then calling \lstinline$StdDraw.polygon$ to draw just the border of a black hexagon, for the sake of game board readability (it is easier to see contrast between adjacent hexes with the use of black borders).

As with a physical Catan board, the dice roll chits need to be placed on top of the hexes, a task performed by the \lstinline$drawChits$ method. A white filled circle and a black unfilled circle are drawn for each hex, using the empirically chosen \lstinline$chitRadius$ (equal to \lstinline$w / 5$) initialized in \lstinline$initCanvas$ to determine the size of these circles. Then, bold Arial text for the dice roll number is drawn in the center of the chit (centered in the hex), where the font size is chosen as \lstinline$w / 5$. Finally, smaller text of the same font face but size \lstinline$w / 11$ is drawn three-quarters of the way down from the hex center, where the text describes the integer ID of the hex being drawn. This is needed on the board because the text-based interface (the subject of a later section) requires that players enter a hex ID when moving the robber piece, an event that takes place whenever a 7 is rolled or a Knight development card is played. One last note about dice roll chits is that the chit on which the robber is placed is denoted by a background colored as \lstinline$StdDraw.DARK_GRAY$ (instead of white) and the dice roll number is (temporarily) replaced with a bold white "R".

\hypertarget{sec:drawing_intersections}{}
\subsubsection{Drawing Intersections}

There are three possibilities for what is drawn at an intersection, determined by the \lstinline$OPEN$, \lstinline$SETTLEMENT$, and \lstinline$CITY$ constants in the \lstinline$Building$ data type (recall from the \hyperlink{sec:intersections}{Intersections} section that each intersection stores a \lstinline$Building$ instance). In the case where nothing has been built yet, a small white circle with a black border is drawn (again, by drawing a filled white circle and then an unfilled black circle), together with the integer ID of the intersection in small font (the same as that used to write the hex ID above). The ID is included so that players can specify where settlements are to be built when interacting with the text-based interface. For intersections where a settlement has been built, a slightly larger filled circle of the player's color (stored in \lstinline$Player.COLORS$ and indexed by the player's ID) with a black border is drawn. Finally, in the case where a city has been built, the same process as for a settlement is followed, with the addition of a black inner circle drawn on top of the settlement (of a radius which is two-thirds of that of a settlement). Once again, the specific values chosen for \lstinline$intersectionRadius$, \lstinline$buildingRadius$, and \lstinline$innerCityRadius$ were determined empirically by drawing boards of different sizes and attempting to scale the dimensions so that intersections look good for any board size (to the extent possible for the given \lstinline$dim$ parameter). It is worth noting here that the appearances chosen for settlements and cities are arbitrary, selected primarily for ease of drawing (since a circle is only determined by its center and radius).

\hypertarget{sec:drawing_ports}{}
\subsubsection{Drawing Ports}

Drawing ports is a simple affair once the coordinates have been calculated. Ports are represented by a black-bordered filled circle of a color denoting the port's resource for the \lstinline$SPECIFIC$ type, or simply black for the \lstinline$GENERIC$ type. The port's trade ratio is rendered as white bold text on top of the port's circle, which is 3:1 for \lstinline$GENERIC$ ports and 2:1 for \lstinline$SPECIFIC$ ports, as specified in the \hyperlink{sec:engaging_in_trade}{Engaging in Trade} section. The final step in the port drawing process is to draw thin black lines from each port to the intersections that are attached to it, so that players can know which intersections yield the improved port trade rates and make settlement building decisions accordingly. It is worth noting here that \lstinline$INLAND$ ports are never rendered since they are not "real" ports but rather a convenience for implementing the default 4:1 resource trade ratio.

\hypertarget{sec:drawing_roads}{}
\subsubsection{Drawing Roads}

The final step in the game board rendering process is to draw the roads built by players during the game. Note that, although \lstinline$Road$ instances are generated together with the board, no roads are drawn until their player ownership has been changed from \lstinline$null$ to an actual \lstinline$Player$ instance using the \lstinline$Road.build$ method. Each road is rendered by drawing a line between the two intersections that are connected by the road (retrieved using the \lstinline$Road.both$ method), where these lines show the player owner's color and also a black border. To achieve the black border effect, a thicker black line is drawn first and then a thinner colored line is drawn on top, where the thicknesses of the lines are set using \lstinline$StdDraw.setPenRadius$ and the empirically generated \lstinline$roadInnerRadius$ and \lstinline$roadOuterRadius$ values. 

\hypertarget{sec:resource_and_development_cards}{}
\subsection{Resource and Development Cards}

The discussion thus far has covered the operation of the program from the terminal command prompt through the \lstinline$Game$ constructor and into the \lstinline$startGame$ method, including the calls to \lstinline$Rules.init$ and \lstinline$setUpBoard$, which creates a new \lstinline$Board$ and then a \lstinline$BoardDraw$ instance tied to that board. The next step in \lstinline$startGame$ is a call to \lstinline$setUpDecks$, which, as its name suggests, is tasked with initializing the data structures used to represent the resource and development cards to be used in the game. These data structures and their initialization are considerably simpler than those required for the game board, so the next two sections which cover them in detail are accordingly much shorter in length.

\hypertarget{sec:the_resource_and_resourcebundle_data_types}{}
\subsubsection{The \lstinline$Resource$ and \lstinline$ResourceBundle$ Data Types}

The \lstinline$Resource$ data type has already been covered in the \hyperlink{sec:resources}{Resources} section, but it is worth repeating here that it serves the dual purpose of representing hex tile resources and the resource cards distributed to players as specified in the game rules (see the \hyperlink{sec:game_setup}{Game Setup} and \hyperlink{sec:rolling_the_dice}{Rolling the Dice} sections for more information on resource card allocation). In order to make it easier to work with bundles of cards (i.e. players' hands, the resource deck, and the cards used in trading and to pay for building game objects), the \lstinline$ResourceBundle$ data type is used, which at its core is simply a two-dimensional \lstinline$ArrayList$ of \lstinline$Resource$ instances. This data type exposes a number of convenience methods for manipulating the underlying array structure, following standard Java nomenclature whenever possible (e.g. for methods such as \lstinline$add$, \lstinline$remove$, \lstinline$isEmpty$, and \lstinline$size$). Most of these methods exist in multiple flavors (using argument overloading) so that the client classes calling them can worry less about dealing with implementation minutiae and more about performing operations relevant to the game. 

The general pattern for these overloaded methods is to have one version for interacting with a single \lstinline$Resource$ or integer resource type and another version for interacting with multiple resources. The \lstinline$add$ methods take either a single \lstinline$Resource$ instance or another \lstinline$ResourceBundle$ instance that is to be merged into \lstinline$this$. Similarly, \lstinline$canRemove$ and \lstinline$remove$ are called either with an integer resource type or an array of size \lstinline$Resource.NUM_TYPES$ specifying the number of each type of resource to be removed (particularly useful when enforcing the resource costs for players building various game objects). The final overloaded method pairs are \lstinline$isEmpty$ and \lstinline$size$ and take either no argument or an integer resource type, where the result is to give information about the size of either the overall data structure or a specific resource "bucket". 

There are two more methods in \lstinline$ResourceBundle$ worth mentioning: \lstinline$removeRandom$ and \lstinline$toString$. The former is used to remove a random resource card from a resource bundle (as the name suggests), which is useful when simulating resource card stealing (recall from the \hyperlink{sec:rolling_the_dice}{Rolling the Dice} section that whenever a player rolls a 7 s/he is entitled to move the robber and steal a resource card from another player). The latter method is used to print the contents of the resource decks and players' hands when it is their turn to play, since there is no graphical inferface for displaying the decks and players must know which resources are available in order to make gameplay decisions. The contents of a \lstinline$ResourceBundle$ are printed according to the following format: \lstinline$Wool: x*; Grain: x*; Lumber: x*; Brick: x*; Ore: x*;$, where \lstinline$*$ is a placeholder for the actual number of cards of each type (note that any zero counts are not printed).

\hypertarget{sec:the_devcard_and_devcardbundle_data_types}{}
\subsubsection{The \lstinline$DevCard$ and \lstinline$DevCardBundle$ Data Types}

The design of the data structures for development cards parallels that of the data structures for resource cards, where \lstinline$DevCard$ wraps around the basic integer types used to denote the different development cards (and also the \lstinline$String$ names for the cards) and \lstinline$DevCardBundle$ provides convenience methods for dealing with groups of cards (i.e. the main game deck and the cards in each player's possession). Like \lstinline$ResourceCardBundle$, the \lstinline$DevCardBundle$ class uses a two-dimensional \lstinline$ArrayList$ as the underlying data structure for storing development cards, and in fact the method names and functionalities are almost identical between the two classes. However, there do exist a few differences that merit mention and brief explanation.

The \lstinline$DevCardBundle$ class enforces an additional check on the maximum size of a bundle, using \lstinline$Rules.MAX_DEV_CARDS$ to ensure that no more cards of any given type than the allowed maximum can be added to a bundle (note that the maximums do not scale up with the board size, unlike the many other board features already discussed). The remaining differences between \lstinline$ResourceBundle$ and \lstinline$DevCardBundle$ are omissions of methods that are useful for manipulating resources but not development cards. Specifically, the versions of \lstinline$canRemove$ and \lstinline$remove$ that take an array of card counts, which are present in \lstinline$ResourceCardBundle$, are absent from \lstinline$DevCardBundle$ because there is never a need for removing multiple cards from a development card bundle at any point in the game (whereas resources are spent to build game objects, development cards are only played or drawn from the deck one at a time).

\hypertarget{sec:the_player_data_type}{}
\subsection{The \lstinline$Player$ Data Type}

Following the initialization of the resource and development card decks in the \lstinline$setUpDecks$ method, the next step in \lstinline$Game$ is to instantiate the players. The \lstinline$setUpPlayers$ method itself is very simple, creating a sufficient number of \lstinline$Player$ instances, as specified by the \lstinline$numPlayers$ field, and then shuffling them to determine a random play order (note that actually rolling dice as in the official Catan rules is unnecessary, although adding the visual feedback for such a process would perhaps improve the user experience). However, the \lstinline$Player$ data type is fairly complex, storing a nontrivial amount of information about the logical possessions of each of the game's players and also implementing a substantial amount of functionality for manipulating player status and enforcing game rules (such as the build costs stored as constants in \lstinline$Rules$).

\hypertarget{sec:relevant_player_information}{}
\subsubsection{Relevant Player Information}

The most basic detail concerning a \lstinline$Player$ instance is its integer ID, stored in \lstinline$id$ and associated with the 8 player colors and \lstinline$String$ names (which are constants). In addition to the standard 4 player colors of blue, orange, red, and white, the implementation presently being discussed includes 4 additional colors (green, light gray, magenta, and pink) so that games played on larger boards can be more interesting. Although additional players beyond these 8 are technically possible, \lstinline$BoardDraw$ treats all players with higher IDs in the same way, drawing their roads, settlements, and cities in black, so in practical terms it is infeasible to play with more than 9 players. 

The next category of relevant player information is that of board objects owned by players, specifically roads, settlements, and cities. Although player properties built on the game board can be directly retrieved from \lstinline$Board$ and its underlying data structures, it is more convenient to keep track of each player's roads and buildings directly in \lstinline$Player$. The \lstinline$roads$, \lstinline$settlements$, and \lstinline$cities$ fields are fairly self-explanatory, storing lists of references to each board object owned by a given player. Note that the latter two refer to \lstinline$Intersection$ objects rather than \lstinline$Building$ objects, since \lstinline$Intersection$ contains not only a \lstinline$Building$ instance but also other useful information (consult the \hyperlink{sec:intersections}{Intersections} section for more details). In addition to the board objects themselves, there also exist 3 integer counts that keep track of how many cost-free structures can be built: \lstinline$freeRoads$, \lstinline$freeSettlements$, and \lstinline$freeCities$. Although the latter is used strictly for debugging, the former two are needed for the special first two turns of the game in which each player is permitted to place 2 settlements and roads free of charge. Appropriate constants exist in \lstinline$Rules$, but it is also necessary to keep track of when these "freebies" are exhausted so that players can start paying resource cards for any further construction.
    
The final category of \lstinline$Player$ fields is that of cards and victory points (VPs). The cards, implemented as \lstinline$ResourceBundle$ and \lstinline$DevCardBundle$ objects, are stored in \lstinline$resourceCards$, \lstinline$devCards$, and \lstinline$playedDevCards$. While there is presently no significant difference between the latter two fields, they exist as separate entities in anticipation of the implementation of a proper graphical interface, since in the physical version of Catan all players can see the development cards that have already been played but not those that have not yet been played. A similar distinction exists with \lstinline$publicVP$ and \lstinline$privateVP$, where the former incorporates VP dev cards that have been played and other VP sources while the latter only includes VP dev cards that have not been played. Finally, \lstinline$hasLongestRoad$ and \lstinline$hasLargestArmy$ represent the large cardboard cards that are given to players who satisfy the eponymous conditions in the physical game, each worth 2 VP as stated in the official rules (\lstinline$LONGEST_ROAD_VP$ and \lstinline$LARGEST_ARMY_VP$ in \lstinline$Rules$).

\hypertarget{sec:enforcing_building_rules}{}
\subsubsection{Enforcing Building Rules}

Recall from the \hyperlink{sec:intersections}{Intersections} and \hyperlink{sec:roads}{Roads} sections that the \lstinline$Building$, \lstinline$Intersection$, and \lstinline$Road$ data types perform no enforcement of build costs. This task is delegated to the \lstinline$Player$ data type, which is adequately equipped to engage in such verification since it has knowledge of the resource cards in a player's hand and, given the resource deck, can pay the appropriate cards for each structure that is built. The \lstinline$canBuild*$ family of methods (where \lstinline$*$ is a wildcard) performs the appropriate checks before any structures can be built, where the flavors taking no arguments verify a player's ability to satisfy build costs and restrictions and the versions that take an appropriate reference to a board data structure check the attempted placement against any possible adjacency requirements and limitations. 

Specifically, the \lstinline$canBuild*$ methods without arguments check whether the appropriate number of resource cards can be removed from a player's hand (the \lstinline$resourceCards$ field) using \lstinline$ResourceBundle.canRemove$ in conjunction with the build cost constants in \lstinline$Rules$ (unless the relevant \lstinline$free*$ fields in \lstinline$Player$ are nonzero, denoting cost-free structures are available) and also whether the player has any structures left to build (recall from the \hyperlink{sec:building_roads_settlements_cities_and_development_cards}{Building Roads, Settlements, Cities, and Development Cards} section that each player may build up to 15 roads, 5 settlements, and 4 cities for the standard board size). The \lstinline$canBuild*$ methods taking specific instances of game objects call upon the argument-free \lstinline$canBuild*$ methods for initial verification and then perform additional verification as dictated by the rules concerning the specific structure type. Roads must generally be placed adjacent to other roads (checked using \lstinline$Road.isNeighbor$), except for the first two roads placed at the beginning of the game, each of which must be adjacent to the settlement placed in the same turn (checked using \lstinline$Road.other$ and the settlement ID). Settlements must generally be placed adjacent to a road, except for the first two settlements (which can be placed anywhere), and cities must always be placed on an intersection where an existing settlement lies. All of these checks and verifications are called by the \lstinline$build*$ methods, and if the results are affirmative then the relevant structures are built (note that methods for development cards exist as well, in addition to those for roads, settlements, and cities).

\hypertarget{sec:player_card_operations}{}
\subsubsection{Player Card Operations}

Aside from the resource card debits that occur when the \lstinline$build*$ methods are called and return successfully, other card operations are also supported by the \lstinline$Player$ class. Resource acquisition is implemented by the two \lstinline$collectResources$ flavors (one for the initial resources given out at the start of the game and the other for when the dice are rolled) and the \lstinline$stealResource$ method variant that receives a stolen resource from another player (i.e. when the robber is moved). On the flip side, resource removal is implemented by the two \lstinline$discard$ variants (which are not actually used in the game) and the \lstinline$stealResource$ version that takes another \lstinline$Player$ instance as a parameter. Combining resource credits and debits, the \lstinline$doPortTrade$ method implements trading resources at ports (refer to the \hyperlink{sec:engaging_in_trade}{Engaging in Trade} section for more details), using the \lstinline$findBestRatio$ method to search the \lstinline$Port$ references stored at each player-owned \lstinline$Intersection$ for the best trade ratio for a given resource. The final card operation implemented in \lstinline$Player$ is performed by the \lstinline$playDevCard$ method, which simply moves a card of the specified type from \lstinline$devCards$ to \lstinline$playedDevCards$ and adjusts the VP values if a VP card is played, decrementing \lstinline$privateVP$ and incrementing \lstinline$publicVP$ (see the \hyperlink{sec:victory_conditions}{Victory Conditions} section for a complete listing of the development cards that grant VP).

\hypertarget{sec:the_userinput_class}{}
\subsection{The \lstinline$UserInput$ Class}

\hypertarget{sec:putting_it_all_together_game_mechanics}{}
\subsection{Putting It All Together: Game Mechanics}



\hypertarget{sec:challenges_encountered}{}
\section{Challenges Encountered}



\hypertarget{sec:future_features}{}
\section{Future Features}

%unimplemented game rules: player trades, 
%fancier ui
%network features

\hypertarget{sec:conclusion}{}
\section{Conclusion}

% end content of the paper
\end{doublespacing} 
\bstctlcite{bstctl:etal, bstctl:nodash, bstctl:simpurl}
\bibliographystyle{IEEEtranS}
% begin bibliography
\bibliography{references}

\end{document}

